# p1-スタート - 设计规范

## API接口设计

### 1. 登录接口

```typescript
// POST /api/v1/auth/login
interface LoginRequest {
  userId: string;
  password: string;
  deviceType: 'PC' | 'SP';
}

interface LoginResponse {
  success: boolean;
  data: {
    sessionToken: string;
    userInfo: UserInfo;
    expiresAt: string;
  };
  error?: {
    code: string;
    message: string;
  };
}

interface UserInfo {
  userId: string;
  userName: string;
  companyId: string;
  permissions: string[];
}
```

### 2. 会话验证接口

```typescript
// GET /api/v1/auth/verify-session
interface VerifySessionResponse {
  success: boolean;
  data: {
    isValid: boolean;
    userInfo: UserInfo;
    expiresAt: string;
  };
}
```

### 3. 登出接口

```typescript
// POST /api/v1/auth/logout
interface LogoutResponse {
  success: boolean;
  message: string;
}
```

## 前端组件设计

### 1. 页面组件结构

```
p1-Start/
├── index.tsx                    # 主页面组件
├── components/
│   ├── LoginForm.tsx           # 登录表单
│   ├── PasswordResetLink.tsx    # 忘记密码链接
│   └── SessionExpiredMessage.tsx # 会话过期消息
├── hooks/
│   ├── useLogin.ts             # 登录hook
│   └── useSession.ts            # 会话hook
├── types/
│   └── auth.ts                 # 类型定义
└── utils/
    └── validation.ts           # 验证工具
```

### 2. 组件代码示例

```tsx
// index.tsx
import React, { useState, useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { LoginForm } from './components/LoginForm';

export const StartPage: React.FC = () => {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  useEffect(() => {
    // 检查是否已登录
    const checkSession = async () => {
      const response = await verifySession();
      if (response.data.isValid) {
        navigate('/p0');
      }
    };
    checkSession();
  }, []);

  const handleLoginSuccess = () => {
    setIsLoggedIn(true);
    navigate('/p0');
  };

  const handleLoginError = (error: string) => {
    // 显示错误消息
  };

  return (
    <div className="start-page">
      <h1>ヤマト運輸 パートナーシステム</h1>

      <LoginForm
        onSuccess={handleLoginSuccess}
        onError={handleLoginError}
      />
    </div>
  );
};
```

```tsx
// LoginForm.tsx
import React, { useState } from 'react';
import { Form, Input, Button, Alert } from 'antd';

interface LoginFormProps {
  onSuccess: () => void;
  onError: (message: string) => void;
}

export const LoginForm: React.FC<LoginFormProps> = ({
  onSuccess,
  onError,
}) => {
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (values: { userId: string; password: string }) => {
    setLoading(true);
    try {
      const response = await login(values.userId, values.password, 'PC');
      if (response.success) {
        onSuccess();
      } else {
        onError(response.error?.message || 'ログインに失敗しました');
      }
    } catch (error) {
      onError('エラーが発生しました');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Form onFinish={handleSubmit} layout="vertical">
      <Form.Item
        name="userId"
        label="ユーザーID"
        rules={[{ required: true, message: 'ユーザーIDを入力してください' }]}
      >
        <Input placeholder="ユーザーID" />
      </Form.Item>

      <Form.Item
        name="password"
        label="パスワード"
        rules={[{ required: true, message: 'パスワードを入力してください' }]}
      >
        <Input.Password placeholder="パスワード" />
      </Form.Item>

      <Form.Item>
        <Button type="primary" htmlType="submit" loading={loading} block>
          ログイン
        </Button>
      </Form.Item>
    </Form>
  );
};
```

## 后端服务设计

### 1. Controller

```java
@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@RequestBody LoginRequest request) {
        LoginResponse response = authService.login(request);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/verify-session")
    public ResponseEntity<VerifySessionResponse> verifySession(
            @AuthenticationPrincipal User user) {
        VerifySessionResponse response = authService.verifySession(user);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/logout")
    public ResponseEntity<LogoutResponse> logout(
            @AuthenticationPrincipal User user) {
        authService.logout(user);
        return ResponseEntity.ok(LogoutResponse.builder()
                .success(true)
                .message("ログアウトしました")
                .build());
    }
}
```

### 2. Service

```java
@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final SessionRepository sessionRepository;
    private final PasswordEncoder passwordEncoder;

    public LoginResponse login(LoginRequest request) {
        User user = userRepository.findById(request.getUserId())
                .orElse(null);

        if (user == null || !passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            return LoginResponse.builder()
                    .success(false)
                    .error(ErrorResponse.builder()
                            .code("INVALID_CREDENTIALS")
                            .message("ユーザーIDまたはパスワードが正しくありません")
                            .build())
                    .build();
        }

        // 创建会话
        Session session = Session.builder()
                .sessionToken(UUID.randomUUID().toString())
                .userId(user.getUserId())
                .deviceType(request.getDeviceType())
                .expiresAt(LocalDateTime.now().plusHours(24))
                .build();

        sessionRepository.save(session);

        return LoginResponse.builder()
                .success(true)
                .data(LoginResponse.LoginData.builder()
                        .sessionToken(session.getSessionToken())
                        .userInfo(UserInfo.builder()
                                .userId(user.getUserId())
                                .userName(user.getUserName())
                                .companyId(user.getCompanyId())
                                .permissions(user.getPermissions())
                                .build())
                        .expiresAt(session.getExpiresAt().toString())
                        .build())
                .build();
    }
}
```

## 数据库表设计

### 1. users 表

```sql
CREATE TABLE users (
    user_id VARCHAR(50) PRIMARY KEY,
    password_hash VARCHAR(255) NOT NULL,
    user_name VARCHAR(200) NOT NULL,
    company_id VARCHAR(50) NOT NULL,
    email VARCHAR(200),
    phone VARCHAR(20),
    account_status ENUM('有効', '無効') DEFAULT '有効',
    failed_login_attempts INT DEFAULT 0,
    locked_until TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_company_id ON users(company_id);
CREATE INDEX idx_users_email ON users(email);
```

### 2. sessions 表

```sql
CREATE TABLE sessions (
    session_token VARCHAR(100) PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    device_type ENUM('PC', 'SP') NOT NULL,
    ip_address VARCHAR(50),
    user_agent TEXT,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_expires ON sessions(expires_at);
```

## 验证规则设计

### 1. 登录验证

```typescript
export const loginValidationRules = {
  userId: [
    { required: true, message: 'ユーザーIDを入力してください' },
    { max: 50, message: 'ユーザーIDは50文字以内で入力してください' },
  ],
  password: [
    { required: true, message: 'パスワードを入力してください' },
    { min: 8, message: 'パスワードは8文字以上で入力してください' },
  ],
};
```

## 安全考虑

### 1. 密码加密

```typescript
// 使用bcrypt加密密码
const hashPassword = (password: string): string => {
  return bcrypt.hashSync(password, 12);
};

const verifyPassword = (password: string, hash: string): boolean => {
  return bcrypt.compareSync(password, hash);
};
```

### 2. 会话管理

```typescript
// 生成安全的会话token
const generateSessionToken = (): string => {
  return crypto.randomBytes(64).toString('hex');
};

// 设置安全的cookie
const setSessionCookie = (token: string, expiresAt: Date) => {
  cookies.set('sessionToken', token, {
    expires: expiresAt,
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
  });
};
```

### 3. 账户锁定

```typescript
// 连续失败登录后锁定账户
const handleFailedLogin = async (userId: string) => {
  const user = await getUser(userId);
  user.failedLoginAttempts += 1;

  if (user.failedLoginAttempts >= 5) {
    user.lockedUntil = new Date(Date.now() + 30 * 60 * 1000); // 锁定30分钟
  }

  await saveUser(user);
};
```

### 4. 暴力破解防护

```typescript
// 限制登录尝试频率
const loginRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 5, // 最多5次尝试
  message: 'ログイン試行回数が上限に達しました。しばらくしてから再度お試しください',
});
```
